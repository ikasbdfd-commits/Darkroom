<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DARKROOM - Horror Multiplayer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Share+Tech+Mono&display=swap');
  
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  :root {
    --red: #ff0033;
    --green: #00ff41;
    --dark: #080808;
    --panel: rgba(0,0,0,0.85);
    --border: #1a1a1a;
  }

  body {
    background: #000;
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    user-select: none;
    cursor: none;
  }

  #cursor {
    position: fixed; width: 16px; height: 16px;
    border: 2px solid var(--red); border-radius: 50%;
    pointer-events: none; z-index: 9999;
    transform: translate(-50%, -50%);
    transition: transform 0.1s;
    box-shadow: 0 0 8px var(--red);
  }

  #gameCanvas {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    display: none;
  }

  /* â”€â”€ LOBBY â”€â”€ */
  #lobby {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: radial-gradient(ellipse at center, #0d0005 0%, #000 70%);
    z-index: 100;
  }

  #lobby::before {
    content: '';
    position: absolute; inset: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,65,0.02) 2px, rgba(0,255,65,0.02) 4px);
    pointer-events: none;
  }

  .logo {
    font-family: 'Creepster', cursive;
    font-size: clamp(3rem, 10vw, 8rem);
    color: var(--red);
    text-shadow: 0 0 30px var(--red), 0 0 60px rgba(255,0,51,0.4);
    letter-spacing: 0.2em;
    animation: flicker 4s infinite;
    margin-bottom: 0.2em;
  }

  .subtitle {
    font-size: 0.8rem; letter-spacing: 0.5em;
    color: rgba(0,255,65,0.5);
    margin-bottom: 3rem;
    text-transform: uppercase;
  }

  @keyframes flicker {
    0%,95%,100% { opacity: 1; }
    96% { opacity: 0.3; }
    97% { opacity: 1; }
    98% { opacity: 0.1; }
    99% { opacity: 0.9; }
  }

  #nameInput {
    background: transparent;
    border: 1px solid var(--green);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.2rem;
    padding: 0.8em 1.5em;
    outline: none;
    text-align: center;
    width: 280px;
    margin-bottom: 1rem;
    box-shadow: 0 0 15px rgba(0,255,65,0.2) inset;
    cursor: none;
  }

  #nameInput::placeholder { color: rgba(0,255,65,0.3); }

  .btn {
    background: transparent;
    border: 1px solid var(--red);
    color: var(--red);
    font-family: 'Share Tech Mono', monospace;
    font-size: 1rem;
    padding: 0.8em 2.5em;
    cursor: none;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    transition: all 0.2s;
    width: 280px;
    margin-bottom: 0.5rem;
  }

  .btn:hover {
    background: var(--red);
    color: #000;
    box-shadow: 0 0 20px var(--red);
  }

  #lobbyStatus {
    margin-top: 2rem;
    font-size: 0.75rem;
    color: rgba(0,255,65,0.6);
    letter-spacing: 0.3em;
    min-height: 1.5em;
    text-align: center;
  }

  #waitingRoom {
    position: fixed; inset: 0;
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    background: radial-gradient(ellipse at center, #050010 0%, #000 70%);
    z-index: 99;
  }

  .waiting-title {
    font-family: 'Creepster', cursive;
    font-size: 3rem; color: var(--red);
    text-shadow: 0 0 20px var(--red);
    margin-bottom: 1rem;
  }

  .player-list {
    border: 1px solid rgba(0,255,65,0.3);
    padding: 1.5rem 3rem;
    min-width: 320px;
    margin-bottom: 2rem;
  }

  .player-entry {
    display: flex; align-items: center; gap: 1rem;
    padding: 0.5rem 0;
    border-bottom: 1px solid rgba(0,255,65,0.1);
    font-size: 0.9rem;
  }

  .player-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); box-shadow: 0 0 6px var(--green); }
  .player-dot.gray { background: #333; box-shadow: none; }

  .role-badge {
    font-size: 0.65rem; padding: 0.2em 0.6em;
    border: 1px solid; letter-spacing: 0.1em;
  }
  .role-badge.runner { border-color: var(--green); color: var(--green); }
  .role-badge.hunter { border-color: var(--red); color: var(--red); }

  /* â”€â”€ HUD â”€â”€ */
  #hud {
    position: fixed; inset: 0;
    pointer-events: none;
    z-index: 50;
    display: none;
  }

  #topBar {
    position: absolute; top: 0; left: 0; right: 0;
    display: flex; justify-content: space-between; align-items: flex-start;
    padding: 1rem 1.5rem;
    background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
  }

  .hud-panel {
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(0,255,65,0.2);
    padding: 0.6rem 1rem;
    font-size: 0.75rem;
    letter-spacing: 0.1em;
  }

  .hud-panel.red { border-color: rgba(255,0,51,0.3); }

  #taskList {
    position: absolute; right: 1rem; top: 50%;
    transform: translateY(-50%);
    background: rgba(0,0,0,0.75);
    border: 1px solid rgba(0,255,65,0.2);
    border-left: 3px solid var(--green);
    padding: 1rem 1.2rem;
    min-width: 220px;
    font-size: 0.72rem;
  }

  .task-title { color: var(--green); letter-spacing: 0.2em; margin-bottom: 0.8rem; font-size: 0.65rem; opacity: 0.7; }

  .task-item {
    display: flex; align-items: center; gap: 0.5rem;
    padding: 0.3rem 0;
    color: rgba(0,255,65,0.7);
    transition: all 0.3s;
  }

  .task-item.done { color: rgba(0,255,65,0.3); text-decoration: line-through; }
  .task-item.active { color: var(--green); }

  .task-check { width: 10px; height: 10px; border: 1px solid rgba(0,255,65,0.5); flex-shrink: 0; }
  .task-item.done .task-check { background: var(--green); border-color: var(--green); }

  #crosshair {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 20px; height: 20px;
    pointer-events: none;
  }

  #crosshair::before, #crosshair::after {
    content: ''; position: absolute;
    background: rgba(0,255,65,0.6);
  }

  #crosshair::before { width: 2px; height: 12px; top: 4px; left: 9px; }
  #crosshair::after { width: 12px; height: 2px; top: 9px; left: 4px; }

  #interactPrompt {
    position: absolute; bottom: 25%; left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    border: 1px solid var(--green);
    padding: 0.5rem 1.5rem;
    font-size: 0.8rem;
    letter-spacing: 0.2em;
    display: none;
    animation: pulse 1s infinite;
    pointer-events: none;
  }

  @keyframes pulse {
    0%,100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  #minimap {
    position: absolute; bottom: 1rem; left: 1rem;
    width: 140px; height: 140px;
    background: rgba(0,0,0,0.8);
    border: 1px solid rgba(0,255,65,0.3);
    overflow: hidden;
  }

  #minimapCanvas { width: 100%; height: 100%; }

  #bottomBar {
    position: absolute; bottom: 0; left: 0; right: 0;
    display: flex; justify-content: center; align-items: flex-end;
    padding: 1rem;
    background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, transparent 100%);
    gap: 1rem;
  }

  .key-hint {
    display: flex; flex-direction: column; align-items: center; gap: 0.2rem;
    font-size: 0.6rem; color: rgba(0,255,65,0.4); letter-spacing: 0.1em;
  }

  .key-box {
    border: 1px solid rgba(0,255,65,0.3);
    padding: 0.2em 0.5em;
    font-size: 0.7rem;
    color: rgba(0,255,65,0.6);
  }

  /* â”€â”€ NOTIFICATIONS â”€â”€ */
  #notifications {
    position: fixed; top: 5rem; left: 50%;
    transform: translateX(-50%);
    z-index: 200;
    display: flex; flex-direction: column; gap: 0.5rem;
    align-items: center;
    pointer-events: none;
  }

  .notif {
    background: rgba(0,0,0,0.9);
    border: 1px solid var(--red);
    color: var(--red);
    padding: 0.5rem 1.5rem;
    font-size: 0.8rem;
    letter-spacing: 0.2em;
    box-shadow: 0 0 20px rgba(255,0,51,0.3);
    animation: notifIn 0.3s ease, notifOut 0.5s 2.5s ease forwards;
    font-family: 'Creepster', cursive;
    font-size: 1rem;
  }

  .notif.green { border-color: var(--green); color: var(--green); box-shadow: 0 0 20px rgba(0,255,65,0.3); }

  @keyframes notifIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes notifOut { to { opacity: 0; transform: translateY(-10px); } }

  /* â”€â”€ CAUGHT / WIN overlays â”€â”€ */
  #overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.9);
    z-index: 300;
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 1rem;
  }

  .overlay-title {
    font-family: 'Creepster', cursive;
    font-size: 5rem;
    text-shadow: 0 0 40px currentColor;
  }

  .overlay-sub { font-size: 0.9rem; letter-spacing: 0.3em; opacity: 0.7; }

  /* â”€â”€ SETTINGS â”€â”€ */
  #settingsPanel {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.95);
    border: 1px solid rgba(0,255,65,0.3);
    padding: 2rem;
    z-index: 400;
    min-width: 340px;
    display: none;
  }

  .settings-title { color: var(--green); letter-spacing: 0.3em; margin-bottom: 1.5rem; font-size: 0.85rem; }

  .setting-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 0.7rem 0;
    border-bottom: 1px solid rgba(0,255,65,0.1);
    font-size: 0.8rem; color: rgba(0,255,65,0.7);
  }

  .toggle {
    width: 40px; height: 20px;
    background: #1a1a1a; border: 1px solid rgba(0,255,65,0.3);
    position: relative; cursor: none;
    transition: background 0.2s;
  }

  .toggle.on { background: rgba(0,255,65,0.2); border-color: var(--green); }
  .toggle::after {
    content: ''; position: absolute;
    width: 14px; height: 14px;
    background: rgba(0,255,65,0.5);
    top: 2px; left: 2px;
    transition: transform 0.2s;
  }
  .toggle.on::after { transform: translateX(20px); background: var(--green); }

  /* Scanner effect */
  #scanline {
    position: fixed; inset: 0;
    background: repeating-linear-gradient(
      0deg, transparent, transparent 3px,
      rgba(0,0,0,0.03) 3px, rgba(0,0,0,0.03) 4px
    );
    pointer-events: none; z-index: 1000;
    animation: scanmove 8s linear infinite;
  }
  @keyframes scanmove {
    0% { background-position: 0 0; }
    100% { background-position: 0 100%; }
  }

  #vignette {
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.7) 100%);
    pointer-events: none; z-index: 999;
  }

  /* Caught effect */
  #bloodScreen {
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(180,0,0,0.6) 100%);
    pointer-events: none; z-index: 500;
    display: none;
    animation: bloodPulse 0.5s ease;
  }
  @keyframes bloodPulse { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }

  /* Controls overlay */
  #controlsGuide {
    position: fixed; bottom: 5rem; right: 1rem;
    background: rgba(0,0,0,0.75);
    border: 1px solid rgba(0,255,65,0.15);
    padding: 0.8rem 1rem;
    font-size: 0.65rem; color: rgba(0,255,65,0.5);
    z-index: 51;
    pointer-events: none;
    display: none;
  }

  .ctrl-row { display: flex; justify-content: space-between; gap: 1.5rem; padding: 0.15rem 0; }
  .ctrl-key { color: rgba(0,255,65,0.8); }

  /* Joystick for mobile */
  #joystickArea {
    position: fixed; bottom: 2rem; left: 2rem;
    width: 120px; height: 120px;
    z-index: 100; display: none;
    pointer-events: all;
  }

  .joystick-base {
    width: 100%; height: 100%;
    border-radius: 50%;
    background: rgba(0,255,65,0.05);
    border: 2px solid rgba(0,255,65,0.2);
    position: relative;
  }

  .joystick-thumb {
    width: 40px; height: 40px; border-radius: 50%;
    background: rgba(0,255,65,0.3); border: 2px solid var(--green);
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 10px rgba(0,255,65,0.4);
  }

  .loader-bar {
    position: fixed; bottom: 0; left: 0;
    height: 3px; background: var(--red);
    width: 0%; transition: width 0.3s;
    z-index: 9999; box-shadow: 0 0 10px var(--red);
  }

  #debugInfo {
    position: fixed; top: 1rem; left: 50%;
    transform: translateX(-50%);
    font-size: 0.6rem; color: rgba(0,255,65,0.3);
    z-index: 1000; pointer-events: none;
  }
</style>
</head>
<body>

<div id="cursor"></div>
<div id="scanline"></div>
<div id="vignette"></div>
<div id="bloodScreen"></div>
<div id="debugInfo"></div>
<div class="loader-bar" id="loaderBar"></div>

<!-- LOBBY -->
<div id="lobby">
  <div class="logo">DARKROOM</div>
  <div class="subtitle">Multiplayer Horror Â· Escape or Hunt</div>
  <input id="nameInput" type="text" placeholder="Ä°SMÄ°NÄ° GÄ°R..." maxlength="16" autocomplete="off" spellcheck="false">
  <button class="btn" onclick="joinGame()">[ ODAYA GÄ°R ]</button>
  <button class="btn" onclick="showSettings()" style="margin-top:0.3rem; border-color: rgba(0,255,65,0.4); color: rgba(0,255,65,0.6); font-size:0.8rem;">[ AYARLAR ]</button>
  <div id="lobbyStatus">BAÄLANTI BEKLENÄ°YOR...</div>
</div>

<!-- WAITING ROOM -->
<div id="waitingRoom">
  <div class="waiting-title">ODADA BEKLENÄ°YOR</div>
  <div id="waitingSubtitle" style="font-size:0.75rem; color:rgba(0,255,65,0.5); letter-spacing:0.3em; margin-bottom:1.5rem;">EN AZ 2 OYUNCU GEREKLÄ°</div>
  <div class="player-list" id="playerList"></div>
  <div id="countdownDisplay" style="font-family:'Creepster',cursive; font-size:3rem; color:var(--red); text-shadow:0 0 20px var(--red); display:none;"></div>
  <div id="roleDisplay" style="font-size:0.8rem; letter-spacing:0.2em; color:rgba(0,255,65,0.6); margin-top:1rem;"></div>
</div>

<!-- GAME CANVAS -->
<canvas id="gameCanvas"></canvas>

<!-- HUD -->
<div id="hud">
  <div id="topBar">
    <div class="hud-panel" id="playerInfo">
      <div id="myName" style="color:var(--green); font-size:0.85rem;"></div>
      <div id="myRole" style="font-size:0.65rem; opacity:0.6; margin-top:0.2rem;"></div>
    </div>
    <div class="hud-panel" style="text-align:center;">
      <div id="gameTimer" style="font-size:1.2rem; color:var(--red);">10:00</div>
      <div style="font-size:0.6rem; opacity:0.5; letter-spacing:0.2em;">KALAN SÃœRE</div>
    </div>
    <div class="hud-panel red" style="text-align:right;">
      <div style="font-size:0.65rem; opacity:0.5; letter-spacing:0.2em; margin-bottom:0.3rem;">OYUNCULAR</div>
      <div id="playerCount" style="font-size:0.85rem; color:var(--red);">0 / 5</div>
    </div>
  </div>

  <div id="crosshair"></div>
  <div id="interactPrompt">[ E ] ETKÄ°LEÅ</div>

  <div id="taskList">
    <div class="task-title">// GÃ–REVLER</div>
    <div id="taskItems"></div>
    <div id="tasksProgress" style="margin-top:0.8rem; font-size:0.65rem; color:rgba(0,255,65,0.4);">0 / 5 TAMAMLANDI</div>
  </div>

  <div id="minimap">
    <canvas id="minimapCanvas" width="140" height="140"></canvas>
  </div>

  <div id="bottomBar">
    <div class="key-hint"><div class="key-box">WASD</div><div>HAREKET</div></div>
    <div class="key-hint"><div class="key-box">MOUSE</div><div>BAKIÅ</div></div>
    <div class="key-hint"><div class="key-box">E</div><div>ETKÄ°LEÅÄ°M</div></div>
    <div class="key-hint"><div class="key-box">SHIFT</div><div>KOÅU</div></div>
    <div class="key-hint"><div class="key-box">ESC</div><div>MENÃœ</div></div>
  </div>
</div>

<div id="controlsGuide">
  <div style="color:var(--green); margin-bottom:0.5rem; letter-spacing:0.2em;">KONTROLLER</div>
  <div class="ctrl-row"><span>Hareket</span><span class="ctrl-key">WASD</span></div>
  <div class="ctrl-row"><span>BakÄ±ÅŸ</span><span class="ctrl-key">MOUSE</span></div>
  <div class="ctrl-row"><span>KoÅŸu</span><span class="ctrl-key">SHIFT</span></div>
  <div class="ctrl-row"><span>EtkileÅŸim</span><span class="ctrl-key">E</span></div>
  <div class="ctrl-row"><span>Ayarlar</span><span class="ctrl-key">ESC</span></div>
</div>

<!-- NOTIFICATIONS -->
<div id="notifications"></div>

<!-- SETTINGS PANEL -->
<div id="settingsPanel">
  <div class="settings-title">// SÄ°STEM AYARLARI</div>
  <div class="setting-row">
    <span>Joystick Modu (Mobil)</span>
    <div class="toggle" id="joystickToggle" onclick="toggleJoystick()"></div>
  </div>
  <div class="setting-row">
    <span>Ses Efektleri</span>
    <div class="toggle on" id="soundToggle" onclick="toggleSetting('soundToggle')"></div>
  </div>
  <div class="setting-row">
    <span>Mouse Hassasiyeti</span>
    <select id="mouseSens" style="background:#111; border:1px solid rgba(0,255,65,0.3); color:var(--green); padding:0.3em; font-family:inherit; font-size:0.75rem; cursor:none;">
      <option value="0.5">DÃ¼ÅŸÃ¼k</option>
      <option value="1" selected>Normal</option>
      <option value="1.8">YÃ¼ksek</option>
      <option value="2.5">Ã‡ok YÃ¼ksek</option>
    </select>
  </div>
  <div class="setting-row">
    <span>Kontrol Rehberi</span>
    <div class="toggle on" id="guideToggle" onclick="toggleGuide()"></div>
  </div>
  <button class="btn" onclick="hideSettings()" style="margin-top:1.5rem; width:100%;">[ KAPAT ]</button>
</div>

<!-- END OVERLAY -->
<div id="overlay">
  <div class="overlay-title" id="overlayTitle"></div>
  <div class="overlay-sub" id="overlaySub"></div>
  <button class="btn" onclick="restartGame()" style="margin-top:2rem; width:260px;">[ YENÄ°DEN OYNA ]</button>
</div>

<!-- Joystick -->
<div id="joystickArea">
  <div class="joystick-base">
    <div class="joystick-thumb" id="joystickThumb"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const REDIS_URL   = "https://informed-hen-11704.upstash.io";
const REDIS_TOKEN = "AS24AAIncDFkZWFiODQ5MTkxNTk0MTAxODk1NWY1Y2RlOTRjYTU3OHAxMTE3MDQ";
const ROOM_KEY    = "darkroom:players";
const STATE_KEY   = "darkroom:state";
const EVENTS_KEY  = "darkroom:events";
const MAX_PLAYERS = 5;
const HUNTER_COUNT = 1;
const GAME_DURATION = 600; // 10 min

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REDIS HELPER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function redisCmd(...args) {
  try {
    const r = await fetch(`${REDIS_URL}/${args.join('/')}`, {
      headers: { Authorization: `Bearer ${REDIS_TOKEN}` }
    });
    const d = await r.json();
    return d.result;
  } catch(e) { return null; }
}

async function redisPipeline(cmds) {
  try {
    const r = await fetch(`${REDIS_URL}/pipeline`, {
      method: 'POST',
      headers: { Authorization: `Bearer ${REDIS_TOKEN}`, 'Content-Type': 'application/json' },
      body: JSON.stringify(cmds)
    });
    const d = await r.json();
    return d;
  } catch(e) { return null; }
}

async function hset(key, field, val) { return redisCmd('hset', key, field, encodeURIComponent(JSON.stringify(val))); }
async function hget(key, field) {
  const v = await redisCmd('hget', key, field);
  try { return v ? JSON.parse(decodeURIComponent(v)) : null; } catch { return null; }
}
async function hgetall(key) {
  const data = await redisCmd('hgetall', key);
  if (!data) return {};
  const obj = {};
  for (let i = 0; i < data.length; i += 2) {
    try { obj[data[i]] = JSON.parse(decodeURIComponent(data[i+1])); } catch { obj[data[i]] = data[i+1]; }
  }
  return obj;
}
async function hdel(key, field) { return redisCmd('hdel', key, field); }
async function lpush(key, val) { return redisCmd('lpush', key, encodeURIComponent(JSON.stringify(val))); }
async function lrange(key, s, e) {
  const d = await redisCmd('lrange', key, s, e);
  if (!d) return [];
  return d.map(v => { try { return JSON.parse(decodeURIComponent(v)); } catch { return null; } }).filter(Boolean);
}
async function ltrim(key, s, e) { return redisCmd('ltrim', key, s, e); }
async function setex(key, sec, val) { return redisCmd('setex', key, sec, encodeURIComponent(JSON.stringify(val))); }
async function get(key) {
  const v = await redisCmd('get', key);
  try { return v ? JSON.parse(decodeURIComponent(v)) : null; } catch { return null; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let myId       = null;
let myName     = '';
let myRole     = null; // 'runner' | 'hunter'
let gamePhase  = 'lobby'; // lobby | waiting | playing | ended
let players    = {};
let gameState  = null;
let pollTimer  = null;
let gameTimer  = null;
let timeLeft   = GAME_DURATION;
let tasks      = [];
let lastEventId = 0;
let settings   = { joystick: false, sound: true, guide: true, sensitivity: 1.0 };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CUSTOM CURSOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const cursorEl = document.getElementById('cursor');
document.addEventListener('mousemove', e => {
  cursorEl.style.left = e.clientX + 'px';
  cursorEl.style.top  = e.clientY + 'px';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showSettings() { document.getElementById('settingsPanel').style.display = 'block'; }
function hideSettings() { document.getElementById('settingsPanel').style.display = 'none'; }

function toggleSetting(id) {
  const el = document.getElementById(id);
  el.classList.toggle('on');
}

function toggleJoystick() {
  const el = document.getElementById('joystickToggle');
  el.classList.toggle('on');
  settings.joystick = el.classList.contains('on');
  document.getElementById('joystickArea').style.display = settings.joystick ? 'block' : 'none';
}

function toggleGuide() {
  const el = document.getElementById('guideToggle');
  el.classList.toggle('on');
  settings.guide = el.classList.contains('on');
  document.getElementById('controlsGuide').style.display = (settings.guide && gamePhase === 'playing') ? 'block' : 'none';
}

document.getElementById('mouseSens').addEventListener('change', function() {
  settings.sensitivity = parseFloat(this.value);
  if (controls) controls.sensitivity = settings.sensitivity * 0.002;
});

document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && gamePhase === 'playing') {
    const sp = document.getElementById('settingsPanel');
    if (sp.style.display === 'block') { hideSettings(); document.body.requestPointerLock(); }
    else { showSettings(); document.exitPointerLock(); }
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NOTIFICATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showNotif(msg, type = 'red') {
  const el = document.createElement('div');
  el.className = `notif ${type === 'green' ? 'green' : ''}`;
  el.textContent = msg;
  document.getElementById('notifications').appendChild(el);
  setTimeout(() => el.remove(), 3200);
}

function updateLoaderBar(pct) {
  document.getElementById('loaderBar').style.width = pct + '%';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  JOIN GAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function joinGame() {
  const name = document.getElementById('nameInput').value.trim();
  if (!name) { showNotif('Ä°SMÄ°NÄ° GÄ°R!'); return; }

  myId   = 'p_' + Math.random().toString(36).substr(2, 8);
  myName = name;

  document.getElementById('lobbyStatus').textContent = 'SUNUCUYA BAÄLANILIYOR...';
  updateLoaderBar(30);

  const playerData = {
    id: myId, name: myName, role: null,
    x: 0, y: 0, z: 0, rx: 0,
    alive: true, online: true,
    joinedAt: Date.now(),
    tasks: []
  };

  await hset(ROOM_KEY, myId, playerData);
  updateLoaderBar(70);

  const allPlayers = await hgetall(ROOM_KEY);
  // Clean offline players (>30s no update)
  const now = Date.now();
  for (const [pid, pd] of Object.entries(allPlayers)) {
    if (pd && now - pd.joinedAt > 60000 && !pd.online) {
      await hdel(ROOM_KEY, pid);
      delete allPlayers[pid];
    }
  }

  players = allPlayers;
  const count = Object.keys(players).length;
  updateLoaderBar(100);

  document.getElementById('lobbyStatus').textContent = `BAÄLANDI! ${count} OYUNCU`;
  setTimeout(() => {
    document.getElementById('lobby').style.display = 'none';
    document.getElementById('waitingRoom').style.display = 'flex';
    gamePhase = 'waiting';
    startPolling();
  }, 800);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  POLLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startPolling() {
  pollTimer = setInterval(poll, 1000);
  poll();
}

async function poll() {
  if (gamePhase === 'ended') return;

  // Update my heartbeat
  const myData = await hget(ROOM_KEY, myId);
  if (myData) {
    myData.joinedAt = Date.now();
    if (gamePhase === 'playing' && camera) {
      myData.x = camera.position.x;
      myData.y = camera.position.y;
      myData.z = camera.position.z;
      myData.rx = camera.rotation.y;
    }
    await hset(ROOM_KEY, myId, myData);
  }

  // Get all players
  const allPlayers = await hgetall(ROOM_KEY);
  players = allPlayers;

  if (gamePhase === 'waiting') {
    updateWaitingRoom();
    checkGameStart();
  } else if (gamePhase === 'playing') {
    updateGamePlayers();
    checkEvents();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WAITING ROOM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateWaitingRoom() {
  const list = document.getElementById('playerList');
  const count = Object.keys(players).length;
  list.innerHTML = '';

  for (let i = 0; i < MAX_PLAYERS; i++) {
    const pd = Object.values(players)[i];
    const el = document.createElement('div');
    el.className = 'player-entry';
    if (pd) {
      el.innerHTML = `
        <div class="player-dot"></div>
        <span style="flex:1; color:${pd.id === myId ? 'var(--green)' : 'rgba(0,255,65,0.7)'}">${pd.name}${pd.id === myId ? ' (SEN)' : ''}</span>
        ${pd.role ? `<span class="role-badge ${pd.role}">${pd.role === 'hunter' ? 'AVCII' : 'KAÃ‡AK'}</span>` : '<span style="font-size:0.65rem;color:rgba(0,255,65,0.3)">BEKLÄ°YOR</span>'}
      `;
    } else {
      el.innerHTML = `<div class="player-dot gray"></div><span style="color:#222">BoÅŸ Slot</span>`;
    }
    list.appendChild(el);
  }

  document.getElementById('waitingSubtitle').textContent = 
    count < 2 ? `${count}/5 OYUNCU Â· EN AZ 2 GEREKLÄ°` : `${count}/5 OYUNCU Â· HAZIR!`;
}

async function checkGameStart() {
  const plist = Object.values(players);
  const count = plist.length;
  if (count < 2) return;

  // Check if game already started
  const state = await get(STATE_KEY);
  if (state && state.phase === 'playing') {
    assignRoles(state);
    startGame(state);
    return;
  }

  // Oldest player is host
  const sorted = plist.sort((a,b) => a.joinedAt - b.joinedAt);
  const isHost = sorted[0].id === myId;

  if (isHost) {
    // Start countdown
    if (!gameState) {
      const countdownEl = document.getElementById('countdownDisplay');
      countdownEl.style.display = 'block';
      let cd = 5;
      const timer = setInterval(async () => {
        countdownEl.textContent = cd;
        if (cd <= 0) {
          clearInterval(timer);
          // Assign roles and start
          const freshPlayers = await hgetall(ROOM_KEY);
          const pArr = Object.values(freshPlayers);
          const shuffled = pArr.sort(() => Math.random() - 0.5);
          const hunterIds = shuffled.slice(0, HUNTER_COUNT).map(p => p.id);

          for (const p of pArr) {
            p.role = hunterIds.includes(p.id) ? 'hunter' : 'runner';
            await hset(ROOM_KEY, p.id, p);
          }

          const newState = {
            phase: 'playing',
            startTime: Date.now(),
            hunterIds,
            tasks: generateTasks(),
            completedTasks: [],
            caughtRunners: []
          };
          await setex(STATE_KEY, 700, newState);
          gameState = newState;
          assignRoles(newState);
          startGame(newState);
        }
        cd--;
      }, 1000);
    }
  }
}

function assignRoles(state) {
  if (myRole) return;
  myRole = state.hunterIds.includes(myId) ? 'hunter' : 'runner';
  const roleText = myRole === 'hunter' ? 'ğŸ”´ AVCI' : 'ğŸŸ¢ KAÃ‡AK';
  document.getElementById('roleDisplay').textContent = `ROLÃœNÄ°Z: ${roleText}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TASKS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generateTasks() {
  return [
    { id: 't1', name: 'ELEKTRÄ°ÄÄ° AÃ‡ (JeneratÃ¶r OdasÄ±)', done: false, x: 15, z: -8 },
    { id: 't2', name: 'ANAHTARI BUL (Depo)', done: false, x: -14, z: 12 },
    { id: 't3', name: 'PENSEYÄ° AL (Alet Ã‡antasÄ±)', done: false, x: 8, z: 18 },
    { id: 't4', name: 'TEL KESME (GÃ¼venlik)', done: false, x: -18, z: -15 },
    { id: 't5', name: 'KAPIY AÃ‡ (Ana Ã‡Ä±kÄ±ÅŸ)', done: false, x: 0, z: -25, locked: true }
  ];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS GAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let scene, camera, renderer, controls;
let playerMeshes = {};
let taskObjects  = [];
let walls = [];
let raycaster;
let clock;
let ambientLight, fogColor;

function startGame(state) {
  if (gamePhase === 'playing') return;
  gamePhase = 'playing';
  tasks = state.tasks || generateTasks();

  document.getElementById('waitingRoom').style.display = 'none';
  document.getElementById('gameCanvas').style.display = 'block';
  document.getElementById('hud').style.display = 'block';
  if (settings.guide) document.getElementById('controlsGuide').style.display = 'block';

  document.getElementById('myName').textContent = myName;
  document.getElementById('myRole').textContent = myRole === 'hunter' ? '[ AVCI ]' : '[ KAÃ‡AK ]';

  showNotif(myRole === 'hunter' ? 'ğŸ”´ SEN AVCISIN! KAÃ‡AKLARÄ° YAKALA!' : 'ğŸŸ¢ KAÃ‡AKSSIN! GÃ–REVLERÄ° TAMAMLA!', myRole === 'hunter' ? 'red' : 'green');

  initThree();
  updateTaskHUD();
  startGameTimer();
}

function initThree() {
  const canvas = document.getElementById('gameCanvas');
  
  renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.BasicShadowMap;
  renderer.setClearColor(0x000000);

  scene = new THREE.Scene();
  fogColor = myRole === 'hunter' ? new THREE.Color(0x110008) : new THREE.Color(0x000a05);
  scene.fog = new THREE.FogExp2(fogColor, 0.08);
  scene.background = fogColor;

  camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(myRole === 'hunter' ? 2 : -2, 1.7, 0);

  clock = new THREE.Clock();
  raycaster = new THREE.Raycaster();

  buildMap();
  buildLighting();
  buildTaskObjects();

  controls = initControls();
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function buildMap() {
  // Floor
  const floorGeo = new THREE.PlaneGeometry(60, 60);
  const floorMat = new THREE.MeshLambertMaterial({ color: 0x0a0a0a });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Ceiling
  const ceilGeo = new THREE.PlaneGeometry(60, 60);
  const ceilMat = new THREE.MeshLambertMaterial({ color: 0x050505 });
  const ceil = new THREE.Mesh(ceilGeo, ceilMat);
  ceil.rotation.x = Math.PI / 2;
  ceil.position.y = 4;
  scene.add(ceil);

  // Wall material
  const wallMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
  const wallMatDark = new THREE.MeshLambertMaterial({ color: 0x0d0d0d });

  function addWall(x, z, w, d, h = 4) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mesh = new THREE.Mesh(geo, wallMat);
    mesh.position.set(x, h/2, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    walls.push(mesh);
    return mesh;
  }

  // Outer walls
  addWall(0, -30, 60, 0.5); // north
  addWall(0,  30, 60, 0.5); // south
  addWall(-30, 0, 0.5, 60); // west
  addWall( 30, 0, 0.5, 60); // east

  // Inner maze walls
  addWall(10, -10, 0.5, 15);
  addWall(-10, 10, 0.5, 15);
  addWall(5, 5, 15, 0.5);
  addWall(-5, -5, 15, 0.5);
  addWall(20, -15, 0.5, 10);
  addWall(-20, 15, 0.5, 10);
  addWall(15, 5, 10, 0.5);
  addWall(-15, -5, 10, 0.5);
  addWall(0, 15, 20, 0.5);
  addWall(0, -15, 20, 0.5);
  addWall(25, 0, 0.5, 20);
  addWall(-25, 0, 0.5, 20);

  // Some corridors & rooms
  addWall(18, 18, 0.5, 8);
  addWall(-18, -18, 0.5, 8);
  addWall(18, -18, 8, 0.5);
  addWall(-18, 18, 8, 0.5);

  // Debris blocks
  const debrisMat = new THREE.MeshLambertMaterial({ color: 0x0f0f0f });
  for (let i = 0; i < 20; i++) {
    const geo = new THREE.BoxGeometry(
      0.5 + Math.random()*1.5,
      0.5 + Math.random()*1.5,
      0.5 + Math.random()*1.5
    );
    const mesh = new THREE.Mesh(geo, debrisMat);
    mesh.position.set(
      (Math.random()-0.5)*50,
      0.5,
      (Math.random()-0.5)*50
    );
    mesh.castShadow = true;
    scene.add(mesh);
    walls.push(mesh);
  }
}

function buildLighting() {
  // Very dim ambient
  const ambient = new THREE.AmbientLight(myRole === 'hunter' ? 0x1a0010 : 0x001a08, 0.3);
  scene.add(ambient);

  // Player flashlight
  const flashlight = new THREE.SpotLight(
    myRole === 'hunter' ? 0xff2200 : 0x00ff66, 
    3, 18, Math.PI/6, 0.5, 1.5
  );
  flashlight.castShadow = false;
  camera.add(flashlight);
  flashlight.target = camera;
  scene.add(camera);

  // Some dim overhead lights (broken)
  const positions = [
    [10, -10], [-10, 10], [20, 20], [-20, -20],
    [0, 0], [15, 15], [-15, -15]
  ];
  positions.forEach(([x, z]) => {
    if (Math.random() > 0.4) { // some broken
      const pt = new THREE.PointLight(0x00ff41, 0.3, 8);
      pt.position.set(x, 3.8, z);
      scene.add(pt);
    }
  });
}

function buildTaskObjects() {
  tasks.forEach(task => {
    const group = new THREE.Group();
    group.position.set(task.x, 0, task.z);

    let mainMesh;
    if (task.id === 't1') {
      // Generator
      const geo = new THREE.BoxGeometry(1.2, 1.5, 0.8);
      const mat = new THREE.MeshLambertMaterial({ color: 0x222200 });
      mainMesh = new THREE.Mesh(geo, mat);
      mainMesh.position.y = 0.75;
      const lightGeo = new THREE.BoxGeometry(0.3, 0.3, 0.1);
      const lightMat = new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x00aa00 });
      const light = new THREE.Mesh(lightGeo, lightMat);
      light.position.set(0, 0.5, 0.41);
      group.add(light);
    } else if (task.id === 't2') {
      // Key
      const geo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
      const mat = new THREE.MeshLambertMaterial({ color: 0xccaa00, emissive: 0x443300 });
      mainMesh = new THREE.Mesh(geo, mat);
      mainMesh.rotation.z = Math.PI/2;
      mainMesh.position.y = 1;
    } else if (task.id === 't3') {
      // Pliers / Pense
      const geo = new THREE.BoxGeometry(0.15, 0.5, 0.08);
      const mat = new THREE.MeshLambertMaterial({ color: 0x444444, emissive: 0x111111 });
      mainMesh = new THREE.Mesh(geo, mat);
      mainMesh.position.y = 1;
    } else if (task.id === 't4') {
      // Wires
      const geo = new THREE.TorusGeometry(0.3, 0.05, 8, 20);
      const mat = new THREE.MeshLambertMaterial({ color: 0xff2200, emissive: 0x440000 });
      mainMesh = new THREE.Mesh(geo, mat);
      mainMesh.position.y = 1.5;
    } else {
      // Door
      const geo = new THREE.BoxGeometry(1.2, 2.5, 0.15);
      const mat = new THREE.MeshLambertMaterial({ color: 0x1a0a00 });
      mainMesh = new THREE.Mesh(geo, mat);
      mainMesh.position.y = 1.25;
    }

    if (mainMesh) { mainMesh.castShadow = true; group.add(mainMesh); }

    // Glow indicator
    const glowGeo = new THREE.SphereGeometry(0.15, 8, 8);
    const glowMat = new THREE.MeshLambertMaterial({ color: 0x00ff41, emissive: 0x00aa00 });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    glow.position.y = 2.5;
    glow.name = 'glow';
    group.add(glow);

    group.userData = { taskId: task.id, taskName: task.name };
    scene.add(group);
    taskObjects.push(group);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initControls() {
  const keys = {};
  let mouseX = 0, mouseY = 0;
  let pitchAngle = 0;
  let sens = settings.sensitivity * 0.002;
  let isLocked = false;

  document.addEventListener('keydown', e => { keys[e.code] = true; });
  document.addEventListener('keyup',   e => { keys[e.code] = false; });

  document.getElementById('gameCanvas').addEventListener('click', () => {
    document.body.requestPointerLock();
  });

  document.addEventListener('pointerlockchange', () => {
    isLocked = document.pointerLockElement === document.body;
  });

  document.addEventListener('mousemove', e => {
    if (!isLocked) return;
    mouseX += e.movementX * sens;
    pitchAngle = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, pitchAngle - e.movementY * sens));
  });

  // Joystick
  let joyX = 0, joyY = 0;
  const joyEl = document.getElementById('joystickArea');
  const thumbEl = document.getElementById('joystickThumb');
  let joyTouch = null;
  let joyOrigin = { x: 0, y: 0 };

  joyEl.addEventListener('touchstart', e => {
    const t = e.touches[0];
    joyOrigin = { x: t.clientX, y: t.clientY };
    joyTouch = t.identifier;
  });

  document.addEventListener('touchmove', e => {
    for (const t of e.touches) {
      if (t.identifier === joyTouch) {
        const dx = t.clientX - joyOrigin.x;
        const dy = t.clientY - joyOrigin.y;
        const len = Math.sqrt(dx*dx + dy*dy);
        const max = 40;
        const cx = Math.max(-max, Math.min(max, dx));
        const cy = Math.max(-max, Math.min(max, dy));
        joyX = cx / max;
        joyY = cy / max;
        thumbEl.style.transform = `translate(calc(-50% + ${cx}px), calc(-50% + ${cy}px))`;
      }
    }
  });

  document.addEventListener('touchend', e => {
    joyX = 0; joyY = 0;
    thumbEl.style.transform = 'translate(-50%, -50%)';
  });

  const ctrl = {
    keys, sensitivity: sens,
    getVelocity() {
      const speed = keys['ShiftLeft'] || keys['ShiftRight'] ? 0.12 : 0.06;
      let dx = 0, dz = 0;

      if (settings.joystick) {
        dx = joyX * speed;
        dz = joyY * speed;
      } else {
        if (keys['KeyW'] || keys['ArrowUp'])    dz -= speed;
        if (keys['KeyS'] || keys['ArrowDown'])  dz += speed;
        if (keys['KeyA'] || keys['ArrowLeft'])  dx -= speed;
        if (keys['KeyD'] || keys['ArrowRight']) dx += speed;
      }
      return { dx, dz };
    },
    update() {
      camera.rotation.order = 'YXZ';
      camera.rotation.y = -mouseX;
      camera.rotation.x = pitchAngle;

      const { dx, dz } = ctrl.getVelocity();
      if (dx !== 0 || dz !== 0) {
        const angle = camera.rotation.y;
        const moveX = dx * Math.cos(angle) - dz * Math.sin(angle);
        const moveZ = dx * Math.sin(angle) + dz * Math.cos(angle);

        const newX = camera.position.x + moveX;
        const newZ = camera.position.z + moveZ;

        // Collision
        if (!checkCollision(newX, camera.position.z)) camera.position.x = newX;
        if (!checkCollision(camera.position.x, newZ)) camera.position.z = newZ;
      }

      camera.position.y = 1.7;
    }
  };

  return ctrl;
}

function checkCollision(x, z) {
  const playerBox = new THREE.Box3(
    new THREE.Vector3(x - 0.3, 0, z - 0.3),
    new THREE.Vector3(x + 0.3, 4, z + 0.3)
  );
  for (const w of walls) {
    const wb = new THREE.Box3().setFromObject(w);
    if (playerBox.intersectsBox(wb)) return true;
  }
  return false;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INTERACT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let nearTask = null;

document.addEventListener('keydown', async e => {
  if (e.code === 'KeyE' && nearTask && gamePhase === 'playing') {
    await doInteract(nearTask);
  }
});

async function doInteract(task) {
  if (myRole !== 'runner') { showNotif('AVCII GÃ–REV YAPAMAZ!'); return; }
  const taskDef = tasks.find(t => t.id === task.taskId);
  if (!taskDef || taskDef.done) return;

  // Check if last task needs pense
  if (taskDef.id === 't4') {
    const penseDone = tasks.find(t => t.id === 't3')?.done;
    if (!penseDone) { showNotif('Ã–NCE PENSEYÄ° AL! (Alet Ã‡antasÄ±)'); return; }
  }
  if (taskDef.id === 't5') {
    const doneTasks = tasks.filter(t => t.done).length;
    if (doneTasks < 4) { showNotif(`Ã–NCE DÄ°ÄER GÃ–REVLERÄ° TAMAMLA! (${doneTasks}/4)`); return; }
  }

  // Simulate task interaction with progress
  showNotif(taskDef.name + ' TAMAMLANIYOR...', 'green');

  await new Promise(r => setTimeout(r, 1500));

  taskDef.done = true;

  // Notify others
  await lpush(EVENTS_KEY, { type: 'task_done', taskId: taskDef.id, playerName: myName, time: Date.now() });
  await ltrim(EVENTS_KEY, 0, 49);

  // Update glow
  const tObj = taskObjects.find(o => o.userData.taskId === taskDef.id);
  if (tObj) {
    const glow = tObj.getObjectByName('glow');
    if (glow) glow.material.color.setHex(0xaaaaaa);
  }

  updateTaskHUD();
  showNotif('âœ“ ' + taskDef.name, 'green');

  // Check win
  if (tasks.filter(t => t.done).length >= tasks.length) {
    endGame('KAÃ‡AKLAR KAZANDI!', 'green');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let frameCount = 0;

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  frameCount++;

  if (controls) controls.update();

  // Glow animation
  const t = clock.getElapsedTime();
  taskObjects.forEach(obj => {
    const glow = obj.getObjectByName('glow');
    if (glow) {
      glow.position.y = 2.5 + Math.sin(t * 2) * 0.1;
      glow.rotation.y += delta * 2;
    }
  });

  // Check nearby tasks
  checkNearbyTasks();

  // Update other player meshes (every 5 frames)
  if (frameCount % 5 === 0) updateOtherPlayerMeshes();

  // Minimap every 10 frames
  if (frameCount % 10 === 0) drawMinimap();

  renderer.render(scene, camera);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NEARBY TASKS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkNearbyTasks() {
  nearTask = null;
  const prompt = document.getElementById('interactPrompt');

  if (myRole !== 'runner') { prompt.style.display = 'none'; return; }

  for (const obj of taskObjects) {
    const dx = obj.position.x - camera.position.x;
    const dz = obj.position.z - camera.position.z;
    const dist = Math.sqrt(dx*dx + dz*dz);
    if (dist < 2.5) {
      const task = tasks.find(t => t.id === obj.userData.taskId);
      if (task && !task.done) {
        nearTask = obj.userData;
        prompt.style.display = 'block';
        prompt.textContent = `[ E ] ${obj.userData.taskName}`;
        return;
      }
    }
  }
  prompt.style.display = 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  OTHER PLAYERS (multiplayer meshes)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateOtherPlayerMeshes() {
  const pList = Object.values(players);

  for (const pd of pList) {
    if (pd.id === myId || !pd.alive) continue;
    if (!pd.x && pd.x !== 0) continue;

    if (!playerMeshes[pd.id]) {
      const geo = new THREE.CapsuleGeometry
        ? new THREE.CapsuleGeometry(0.3, 1.4, 4, 8)
        : new THREE.CylinderGeometry(0.3, 0.3, 1.7, 8);

      const mat = new THREE.MeshLambertMaterial({
        color: pd.role === 'hunter' ? 0xff0022 : 0x00ff41
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;

      // Head
      const headGeo = new THREE.SphereGeometry(0.2, 8, 8);
      const head = new THREE.Mesh(headGeo, mat);
      head.position.y = 1.2;
      mesh.add(head);

      scene.add(mesh);
      playerMeshes[pd.id] = mesh;
    }

    const mesh = playerMeshes[pd.id];
    mesh.position.set(pd.x || 0, 0.85, pd.z || 0);
    if (pd.rx !== undefined) mesh.rotation.y = pd.rx + Math.PI;
  }

  // Remove disconnected
  for (const [pid, mesh] of Object.entries(playerMeshes)) {
    if (!players[pid]) {
      scene.remove(mesh);
      delete playerMeshes[pid];
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HUNTER - CATCH RUNNER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function checkHunterCatch() {
  if (myRole !== 'hunter') return;
  
  const pList = Object.values(players);
  for (const pd of pList) {
    if (pd.role !== 'runner' || !pd.alive) continue;
    const dx = (pd.x||0) - camera.position.x;
    const dz = (pd.z||0) - camera.position.z;
    const dist = Math.sqrt(dx*dx + dz*dz);

    if (dist < 1.5) {
      // Caught!
      pd.alive = false;
      await hset(ROOM_KEY, pd.id, pd);
      await lpush(EVENTS_KEY, { type: 'caught', caughtId: pd.id, caughtName: pd.name, hunterName: myName, time: Date.now() });
      await ltrim(EVENTS_KEY, 0, 49);
      showNotif(`YAKALADIM: ${pd.name}!`, 'red');

      // Blood screen
      const bs = document.getElementById('bloodScreen');
      bs.style.display = 'block';
      setTimeout(() => bs.style.display = 'none', 600);

      // Check if all runners caught
      const runners = pList.filter(p => p.role === 'runner');
      const alive = runners.filter(p => p.id !== pd.id && p.alive);
      if (alive.length === 0) endGame('AVCI KAZANDI! TÃœM KAÃ‡AKLAR YAKALANDI!', 'red');
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EVENTS (polling)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function checkEvents() {
  const events = await lrange(EVENTS_KEY, 0, 19);
  if (!events) return;

  for (const ev of events) {
    if (!ev || !ev.time) continue;
    if (ev.time <= lastEventId) continue;
    lastEventId = ev.time;

    if (ev.type === 'task_done' && ev.playerName !== myName) {
      const task = tasks.find(t => t.id === ev.taskId);
      if (task) {
        task.done = true;
        updateTaskHUD();
        showNotif(`${ev.playerName}: ${task.name}`, 'green');
      }
    }

    if (ev.type === 'caught') {
      if (ev.caughtId === myId) {
        // I was caught!
        showNotif('YAKALANDIN! OYUN BÄ°TTÄ°!', 'red');
        const bs = document.getElementById('bloodScreen');
        bs.style.display = 'block';
        setTimeout(() => bs.style.display = 'none', 2000);
        setTimeout(() => endGame('YAKALANDIN!', 'red'), 2000);
      } else if (ev.hunterName !== myName) {
        showNotif(`${ev.caughtName} YAKALANDI!`, 'red');
      }
    }
  }

  // Hunter check every 200ms effectively through poll
  if (myRole === 'hunter') await checkHunterCatch();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MINIMAP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawMinimap() {
  const canvas = document.getElementById('minimapCanvas');
  const ctx = canvas.getContext('2d');
  const W = 140, H = 140;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(0, 0, W, H);

  const scale = W / 60;
  const cx = W/2 - camera.position.x * scale;
  const cz = H/2 - camera.position.z * scale;

  // Walls
  ctx.fillStyle = '#1a1a1a';
  for (const w of walls) {
    const box = new THREE.Box3().setFromObject(w);
    const x = box.min.x * scale + cx;
    const z = box.min.z * scale + cz;
    const ww = (box.max.x - box.min.x) * scale;
    const hh = (box.max.z - box.min.z) * scale;
    ctx.fillRect(x, z, ww, hh);
  }

  // Tasks
  for (const task of tasks) {
    const tx = tasks.indexOf(task);
    const t = tasks[tx];
    ctx.fillStyle = t.done ? '#333' : '#00ff41';
    ctx.beginPath();
    ctx.arc(t.x * scale + cx, t.z * scale + cz, 3, 0, Math.PI*2);
    ctx.fill();
  }

  // Other players
  for (const pd of Object.values(players)) {
    if (pd.id === myId || !pd.alive || !pd.x) continue;
    ctx.fillStyle = pd.role === 'hunter' ? '#ff0033' : '#00ff41';
    ctx.beginPath();
    ctx.arc((pd.x||0) * scale + cx, (pd.z||0) * scale + cz, 3, 0, Math.PI*2);
    ctx.fill();
  }

  // Me
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(W/2, H/2, 4, 0, Math.PI*2);
  ctx.fill();

  // Direction arrow
  const ang = -camera.rotation.y;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(W/2, H/2);
  ctx.lineTo(W/2 + Math.sin(ang) * 8, H/2 - Math.cos(ang) * 8);
  ctx.stroke();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TASK HUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateTaskHUD() {
  const container = document.getElementById('taskItems');
  container.innerHTML = '';
  const done = tasks.filter(t => t.done).length;

  for (const task of tasks) {
    const el = document.createElement('div');
    el.className = `task-item ${task.done ? 'done' : ''}`;
    el.innerHTML = `<div class="task-check"></div>${task.name}`;
    container.appendChild(el);
  }

  document.getElementById('tasksProgress').textContent = `${done} / ${tasks.length} TAMAMLANDI`;
  document.getElementById('playerCount').textContent = `${Object.keys(players).length} / ${MAX_PLAYERS}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME TIMER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startGameTimer() {
  const state = gameState;
  gameTimer = setInterval(() => {
    if (gamePhase !== 'playing') { clearInterval(gameTimer); return; }

    const elapsed = Math.floor((Date.now() - (state?.startTime || Date.now())) / 1000);
    timeLeft = Math.max(0, GAME_DURATION - elapsed);

    const mins = Math.floor(timeLeft / 60).toString().padStart(2,'0');
    const secs = (timeLeft % 60).toString().padStart(2,'0');
    const timerEl = document.getElementById('gameTimer');
    timerEl.textContent = `${mins}:${secs}`;

    if (timeLeft <= 60) timerEl.style.color = 'var(--red)';
    if (timeLeft <= 0) {
      if (myRole === 'runner') endGame('ZAMAN DOLDU! KAÃ‡AKLAR KAZANDI!', 'green');
      else endGame('ZAMAN DOLDU! KAÃ‡AKLAR KURTULDU!', 'red');
    }
  }, 1000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  END GAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function endGame(msg, type) {
  if (gamePhase === 'ended') return;
  gamePhase = 'ended';
  clearInterval(pollTimer);
  clearInterval(gameTimer);
  document.exitPointerLock();

  // Cleanup redis
  await hdel(ROOM_KEY, myId);

  const overlay = document.getElementById('overlay');
  const title   = document.getElementById('overlayTitle');
  const sub     = document.getElementById('overlaySub');

  title.textContent = msg;
  title.style.color = type === 'green' ? 'var(--green)' : 'var(--red)';
  sub.textContent   = myRole === 'hunter' 
    ? (type === 'green' ? 'AVCI OLARAK KAZANDÄ°N!' : 'AVCI OLARAK KAYBETTÄ°N')
    : (type === 'green' ? 'KAÃ‡AK OLARAK KAZANDÄ°N!' : 'KAÃ‡AK OLARAK KAYBETTÄ°N');

  overlay.style.display = 'flex';
  showNotif(msg, type);
}

function restartGame() {
  location.reload();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT STATUS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(async () => {
  try {
    const pong = await redisCmd('ping');
    document.getElementById('lobbyStatus').textContent = 
      pong === 'PONG' ? 'âœ“ SUNUCU BAÄLANTISI HAZIR' : 'âš  SUNUCU YANIT VERMÄ°YOR';
  } catch {
    document.getElementById('lobbyStatus').textContent = 'âœ— BAÄLANTI HATASI';
  }
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DEBUG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
setInterval(() => {
  if (gamePhase === 'playing' && camera) {
    document.getElementById('debugInfo').textContent = 
      `POS: ${camera.position.x.toFixed(1)}, ${camera.position.z.toFixed(1)} | OYUNCULAR: ${Object.keys(players).length}`;
  }
}, 500);

</script>
</body>
</html>
