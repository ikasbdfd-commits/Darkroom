<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>KA√áI≈û üî¶</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;font-family:'Segoe UI',sans-serif;overflow:hidden;touch-action:none}
#c{position:fixed;inset:0;display:block}

/* LOBBY */
#lobby{
  position:fixed;inset:0;z-index:200;
  background:radial-gradient(ellipse at center, #0a0a0f 0%, #000 100%);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  padding:24px;
}
.lb-skull{font-size:4em;animation:pulse 2s infinite}
@keyframes pulse{0%,100%{transform:scale(1);filter:brightness(1)}50%{transform:scale(1.1);filter:brightness(1.4) drop-shadow(0 0 20px #ef4444)}}
.lb-title{
  font-size:2.8em;font-weight:900;letter-spacing:3px;margin:8px 0 4px;
  color:#ef4444;text-shadow:0 0 30px #ef4444,0 0 60px #ef444488;
}
.lb-sub{font-size:0.8em;color:#555;margin-bottom:32px;letter-spacing:2px;text-transform:uppercase}
.card{
  background:rgba(255,255,255,0.03);
  border:1px solid rgba(255,60,60,0.2);
  border-radius:20px;padding:28px 22px;
  width:100%;max-width:340px;
  backdrop-filter:blur(20px);
  box-shadow:0 0 40px rgba(239,68,68,0.1),0 25px 60px rgba(0,0,0,0.8);
}
.field{margin-bottom:16px}
.field label{display:block;font-size:0.72em;font-weight:700;color:#ef4444;text-transform:uppercase;letter-spacing:2px;margin-bottom:8px}
.field input{
  width:100%;padding:14px 16px;
  background:rgba(255,255,255,0.04);
  border:1.5px solid rgba(255,255,255,0.08);
  border-radius:12px;color:#fff;
  font-size:1em;font-weight:600;outline:none;
  transition:border-color 0.2s,box-shadow 0.2s;
}
.field input:focus{border-color:#ef4444;box-shadow:0 0 15px rgba(239,68,68,0.25)}
.field input::placeholder{color:#333}
.div-or{text-align:center;color:#333;font-size:0.8em;margin:14px 0;position:relative}
.div-or::before,.div-or::after{content:'';position:absolute;top:50%;width:40%;height:1px;background:rgba(255,255,255,0.07)}
.div-or::before{left:0}.div-or::after{right:0}
.btn{
  width:100%;padding:15px;border:none;border-radius:14px;
  font-size:1em;font-weight:900;cursor:pointer;
  transition:all 0.15s;letter-spacing:1px;margin-top:6px;
}
.btn:active{transform:scale(0.96)}
.btn-r{background:linear-gradient(135deg,#7f1d1d,#ef4444);color:#fff;box-shadow:0 6px 25px rgba(239,68,68,0.4)}
.btn-g{background:linear-gradient(135deg,#14532d,#22c55e);color:#fff;box-shadow:0 6px 25px rgba(34,197,94,0.3)}

/* WAITING */
#waiting{
  position:fixed;inset:0;z-index:200;
  background:radial-gradient(ellipse, #0a0a0f, #000);
  display:none;flex-direction:column;align-items:center;justify-content:center;
  padding:24px;
}
.rcode{font-size:4em;font-weight:900;letter-spacing:12px;color:#ef4444;text-shadow:0 0 20px #ef4444;margin:10px 0}
.pslot{
  display:flex;align-items:center;gap:12px;
  padding:12px 16px;border-radius:12px;
  background:rgba(255,255,255,0.04);
  border:1px solid rgba(255,255,255,0.07);
  margin-bottom:10px;width:100%;max-width:300px;
}
.pdot{width:10px;height:10px;border-radius:50%}
.pdot.on{background:#22c55e;box-shadow:0 0 8px #22c55e}
.pdot.off{background:#333}
.pname{font-size:0.9em;font-weight:700;color:#ccc}
.wdots{display:flex;gap:7px;margin-top:20px}
.wdots span{width:9px;height:9px;border-radius:50%;background:#ef4444;animation:bop 1.2s infinite}
.wdots span:nth-child(2){animation-delay:.2s}.wdots span:nth-child(3){animation-delay:.4s}
@keyframes bop{0%,60%,100%{transform:translateY(0);opacity:.3}30%{transform:translateY(-10px);opacity:1}}

/* GAME CANVAS OVERLAY */
#hud{position:fixed;inset:0;z-index:10;pointer-events:none}

/* Vignette */
#vignette{
  position:fixed;inset:0;z-index:9;pointer-events:none;
  background:radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.95) 100%);
}

/* Flashlight off overlay */
#darkOverlay{
  position:fixed;inset:0;z-index:8;pointer-events:none;
  background:rgba(0,0,0,0);transition:background 0.3s;
}

/* Top HUD */
#topHud{
  position:fixed;top:12px;left:50%;transform:translateX(-50%);
  z-index:20;display:none;
  display:flex;align-items:center;gap:14px;
  background:rgba(0,0,0,0.7);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:30px;padding:8px 18px;
  backdrop-filter:blur(10px);
}
.hud-item{display:flex;align-items:center;gap:6px;font-size:0.8em;font-weight:700}
#batteryBar{width:50px;height:6px;background:#222;border-radius:3px;overflow:hidden}
#batteryFill{height:100%;background:#22c55e;border-radius:3px;transition:width 0.5s,background 0.5s;width:100%}
#flashBtn{
  position:fixed;bottom:180px;right:20px;z-index:30;
  width:56px;height:56px;border-radius:50%;border:none;
  background:rgba(0,0,0,0.75);border:2px solid rgba(255,255,255,0.2);
  font-size:1.5em;cursor:pointer;
  box-shadow:0 4px 15px rgba(0,0,0,0.5);
  transition:all 0.2s;pointer-events:all;
  display:none;
}
#flashBtn.on{border-color:#fbbf24;box-shadow:0 0 15px rgba(251,191,36,0.5)}
#flashBtn:active{transform:scale(0.9)}

/* Joystick */
#joyZone{
  position:fixed;bottom:20px;left:20px;z-index:30;
  width:130px;height:130px;
  display:none;pointer-events:all;
}
#joyBase{
  width:130px;height:130px;border-radius:50%;
  background:rgba(255,255,255,0.06);
  border:2px solid rgba(255,255,255,0.15);
  position:relative;
}
#joyKnob{
  width:50px;height:50px;border-radius:50%;
  background:rgba(239,68,68,0.7);
  border:2px solid rgba(239,68,68,0.9);
  box-shadow:0 0 15px rgba(239,68,68,0.4);
  position:absolute;top:50%;left:50%;
  transform:translate(-50%,-50%);
  transition:none;
}

/* Camera look zone */
#lookZone{
  position:fixed;bottom:0;right:0;z-index:20;
  width:55%;height:100%;pointer-events:all;
  /* transparent */
}

/* Mini map */
#minimap{
  position:fixed;top:12px;right:12px;z-index:25;
  width:90px;height:90px;
  background:rgba(0,0,0,0.8);
  border:1px solid rgba(255,255,255,0.15);
  border-radius:10px;
  display:none;overflow:hidden;
}
#minimapCanvas{width:90px;height:90px}

/* Monster warning */
#monWarn{
  position:fixed;inset:0;z-index:40;pointer-events:none;
  border:0px solid #ef4444;transition:border-width 0.1s,opacity 0.1s;opacity:0;
}

/* Caught screen */
#deathScreen{
  position:fixed;inset:0;z-index:300;
  background:rgba(0,0,0,0);
  display:none;flex-direction:column;
  align-items:center;justify-content:center;
  transition:background 1s;
}
#deathScreen.show{background:rgba(139,0,0,0.85)}
.death-title{font-size:3em;font-weight:900;color:#ef4444;text-shadow:0 0 40px #ef4444;animation:flicker 0.3s infinite alternate;display:none}
@keyframes flicker{0%{opacity:1}100%{opacity:0.7}}
.death-sub{font-size:1em;color:#aaa;margin:8px 0 28px;display:none}
.death-btns{display:flex;flex-direction:column;gap:10px;width:260px;display:none}

/* WIN screen */
#winScreen{
  position:fixed;inset:0;z-index:300;
  background:rgba(0,20,0,0.93);
  display:none;flex-direction:column;
  align-items:center;justify-content:center;
  padding:30px;
}
.win-emoji{font-size:4em;margin-bottom:12px;animation:bounce 0.6s infinite alternate}
@keyframes bounce{0%{transform:translateY(0)}100%{transform:translateY(-15px)}}
.win-title{font-size:2.5em;font-weight:900;color:#22c55e;text-shadow:0 0 30px #22c55e;margin-bottom:8px}

/* Breath/pulse effect when monster near */
#breathOverlay{
  position:fixed;inset:0;z-index:7;pointer-events:none;
  background:radial-gradient(ellipse,rgba(139,0,0,0) 40%,rgba(139,0,0,0.4) 100%);
  opacity:0;transition:opacity 0.5s;
}

/* Name tags in 3D */
#nameTagsLayer{position:fixed;inset:0;z-index:15;pointer-events:none}
.ntag{
  position:absolute;
  background:rgba(0,0,0,0.75);
  border:1.5px solid rgba(255,255,255,0.2);
  border-radius:10px;padding:4px 10px;
  font-size:0.7em;font-weight:800;color:#fff;
  white-space:nowrap;transform:translate(-50%,-100%);
  pointer-events:none;
  text-shadow:0 1px 4px #000;
}

/* Timer */
#timer{font-size:0.85em;color:#aaa;font-weight:700}

/* Compass */
#compass2{
  position:fixed;top:65px;right:12px;z-index:25;
  width:36px;height:36px;
  background:rgba(0,0,0,0.7);
  border:1px solid rgba(255,255,255,0.12);
  border-radius:50%;
  display:none;flex-direction:column;
  align-items:center;justify-content:center;
  font-size:0.6em;color:#aaa;font-weight:700;line-height:1.2;
}
</style>
</head>
<body>

<!-- LOBBY -->
<div id="lobby">
  <div class="lb-skull">üíÄ</div>
  <div class="lb-title">KA√áI≈û</div>
  <p class="lb-sub">Labirentten √ßƒ±k ‚Äî ya da √∂l</p>
  <div class="card">
    <div class="field">
      <label>ƒ∞smin</label>
      <input id="inName" type="text" placeholder="Adƒ±nƒ± gir..." maxlength="12">
    </div>
    <button class="btn btn-r" onclick="createRoom()">‚ö° Oda Olu≈ütur</button>
    <div class="div-or">‚Äî ya da ‚Äî</div>
    <div class="field">
      <label>Oda Kodu</label>
      <input id="inCode" type="text" placeholder="X X X X" maxlength="4" style="text-transform:uppercase;letter-spacing:6px;font-size:1.4em;text-align:center">
    </div>
    <button class="btn btn-g" onclick="joinRoom()">üö™ Katƒ±l</button>
  </div>
</div>

<!-- WAITING -->
<div id="waiting">
  <div style="font-size:0.75em;color:#444;letter-spacing:3px;text-transform:uppercase">ODA KODU</div>
  <div class="rcode" id="dispCode">----</div>
  <div style="font-size:0.8em;color:#444;margin-bottom:16px">Arkada≈üƒ±na g√∂nder</div>
  <div id="wPlayers" style="width:100%"></div>
  <div class="wdots"><span></span><span></span><span></span></div>
  <div id="wMsg" style="font-size:0.8em;color:#444;margin-top:10px">Bekleniyor...</div>
</div>

<!-- GAME -->
<canvas id="c"></canvas>
<div id="vignette"></div>
<div id="darkOverlay"></div>
<div id="breathOverlay"></div>
<div id="monWarn"></div>

<div id="topHud" style="display:none">
  <div class="hud-item">üî¶
    <div id="batteryBar"><div id="batteryFill"></div></div>
  </div>
  <div id="timer" class="hud-item">‚è± 00:00</div>
  <div class="hud-item" id="partnerId" style="color:#22c55e;font-size:0.75em"></div>
</div>

<button id="flashBtn" onclick="toggleFlash()">üî¶</button>

<div id="joyZone">
  <div id="joyBase">
    <div id="joyKnob"></div>
  </div>
</div>

<div id="lookZone"></div>
<div id="nameTagsLayer"></div>

<div id="minimap" style="display:none">
  <canvas id="minimapCanvas" width="90" height="90"></canvas>
</div>

<div id="compass2" style="display:none">
  <span id="cmpD">K</span>
  <span id="cmpDg">0¬∞</span>
</div>

<!-- DEATH -->
<div id="deathScreen">
  <div class="death-title" id="dTitle">üíÄ YAKALANDIN!</div>
  <div class="death-sub" id="dSub">Canavar sizi buldu</div>
  <div class="death-btns" id="dBtns">
    <button class="btn btn-r" onclick="restartGame()">üîÑ Tekrar</button>
    <button class="btn" style="background:rgba(255,255,255,0.07);color:#aaa" onclick="goLobby()">üè† Men√º</button>
  </div>
</div>

<!-- WIN -->
<div id="winScreen">
  <div class="win-emoji">üö™</div>
  <div class="win-title">KA√áTINIZ!</div>
  <div style="color:#aaa;margin-bottom:24px;font-size:0.9em" id="winTime"></div>
  <button class="btn btn-g" style="max-width:260px" onclick="restartGame()">üîÑ Tekrar</button>
  <button class="btn" style="max-width:260px;background:rgba(255,255,255,0.07);color:#aaa;margin-top:8px" onclick="goLobby()">üè† Men√º</button>
</div>

<!-- THREE.JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
//  REDIS
// ============================================================
const RU = "https://informed-hen-11704.upstash.io";
const RT = "AS24AAIncDFkZWFiODQ5MTkxNTk0MTAxODk1NWY1Y2RlOTRjYTU3OHAxMTE3MDQ";

async function rGet(k){
  try{const r=await fetch(`${RU}/get/${encodeURIComponent(k)}`,{headers:{Authorization:`Bearer ${RT}`}});
  const d=await r.json();return d.result?JSON.parse(d.result):null}catch{return null}
}
async function rSet(k,v,ex=600){
  try{await fetch(`${RU}/set/${encodeURIComponent(k)}/${encodeURIComponent(JSON.stringify(v))}?ex=${ex}`,
  {headers:{Authorization:`Bearer ${RT}`}})}catch{}
}

// ============================================================
//  MAZE GENERATOR (Recursive Backtracker)
// ============================================================
const MAZE_W = 19, MAZE_H = 19;
let mazeGrid = []; // 0=wall,1=path

function generateMaze(){
  mazeGrid = Array.from({length:MAZE_H},()=>Array(MAZE_W).fill(0));
  const visited = Array.from({length:MAZE_H},()=>Array(MAZE_W).fill(false));
  const stack = [];
  const start = {x:1,y:1};
  mazeGrid[start.y][start.x]=1;
  visited[start.y][start.x]=true;
  stack.push(start);
  const dirs=[{dx:2,dy:0},{dx:-2,dy:0},{dx:0,dy:2},{dx:0,dy:-2}];

  while(stack.length){
    const cur = stack[stack.length-1];
    const shuffled = dirs.slice().sort(()=>Math.random()-0.5);
    let moved=false;
    for(const d of shuffled){
      const nx=cur.x+d.dx, ny=cur.y+d.dy;
      if(nx>0&&nx<MAZE_W-1&&ny>0&&ny<MAZE_H-1&&!visited[ny][nx]){
        mazeGrid[ny][nx]=1;
        mazeGrid[cur.y+d.dy/2][cur.x+d.dx/2]=1;
        visited[ny][nx]=true;
        stack.push({x:nx,y:ny});
        moved=true;break;
      }
    }
    if(!moved)stack.pop();
  }
  // Exit
  mazeGrid[MAZE_H-2][MAZE_W-2]=2; // exit
  // Make sure corners open
  mazeGrid[1][1]=1;
  return mazeGrid;
}

// ============================================================
//  THREE SETUP
// ============================================================
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:false});
renderer.setPixelRatio(Math.min(devicePixelRatio,1.5));
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
renderer.toneMapping=THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure=0.8;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, 0.18);

const camera = new THREE.PerspectiveCamera(70, 1, 0.05, 30);

function resize(){
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
}
resize();
window.addEventListener('resize',resize);

// ============================================================
//  LIGHTS
// ============================================================
const ambient = new THREE.AmbientLight(0x111122, 0.4);
scene.add(ambient);

// Flashlight (spot)
const flash = new THREE.SpotLight(0xfff8e7, 0, 15, Math.PI*0.13, 0.4, 1.5);
flash.castShadow=true;
flash.shadow.mapSize.set(512,512);
camera.add(flash);
flash.position.set(0,0,0);
flash.target.position.set(0,0,-1);
camera.add(flash.target);
scene.add(camera);

// Eerie ambient glow (very dim red)
const eerieLight = new THREE.PointLight(0x330000, 0.3, 8);
scene.add(eerieLight);

// ============================================================
//  MAZE 3D BUILD
// ============================================================
const CELL = 2.5;
const WALL_H = 2.8;
const wallMat = new THREE.MeshLambertMaterial({color:0x1a1a1a});
const floorMat = new THREE.MeshLambertMaterial({color:0x111111});
const ceilMat  = new THREE.MeshLambertMaterial({color:0x0a0a0a});
const exitMat  = new THREE.MeshLambertMaterial({color:0x003300, emissive:0x002200});
let exitMarker;

function buildMaze3D(){
  // Clear previous
  const toRemove=[];
  scene.traverse(o=>{if(o.userData.maze)toRemove.push(o)});
  toRemove.forEach(o=>scene.remove(o));

  const wGeo = new THREE.BoxGeometry(CELL,WALL_H,CELL);
  const fGeo = new THREE.PlaneGeometry(CELL,CELL);

  for(let y=0;y<MAZE_H;y++){
    for(let x=0;x<MAZE_W;x++){
      const wx=x*CELL, wz=y*CELL;
      if(mazeGrid[y][x]===0){
        const wall=new THREE.Mesh(wGeo,wallMat);
        wall.position.set(wx,WALL_H/2,wz);
        wall.castShadow=true; wall.receiveShadow=true;
        wall.userData.maze=true;
        scene.add(wall);
      } else {
        // Floor
        const fl=new THREE.Mesh(fGeo,mazeGrid[y][x]===2?exitMat:floorMat);
        fl.rotation.x=-Math.PI/2; fl.position.set(wx,0,wz);
        fl.receiveShadow=true; fl.userData.maze=true;
        scene.add(fl);
        // Ceiling
        const ce=new THREE.Mesh(fGeo,ceilMat);
        ce.rotation.x=Math.PI/2; ce.position.set(wx,WALL_H,wz);
        ce.userData.maze=true;
        scene.add(ce);
      }
      if(mazeGrid[y][x]===2){
        // Exit glow
        const exitGlow=new THREE.PointLight(0x00ff44,1.5,4);
        exitGlow.position.set(wx,0.5,wz);
        exitGlow.userData.maze=true;
        scene.add(exitGlow);
        exitMarker={x:wx,z:wz};
      }
    }
  }
}

// ============================================================
//  MONSTER
// ============================================================
let monster={x:0,z:0,yaw:0,speed:0.018,group:null,alive:true};
let monsterPathTimer=0;
let monsterTarget={x:0,z:0};

function buildMonster(){
  if(monster.group)scene.remove(monster.group);
  const g=new THREE.Group();

  // Body
  const bodyG=new THREE.BoxGeometry(0.7,1.1,0.5);
  const bodyM=new THREE.MeshLambertMaterial({color:0x1a0a0a});
  const body=new THREE.Mesh(bodyG,bodyM);
  body.position.y=0.55;
  g.add(body);

  // Head
  const headG=new THREE.BoxGeometry(0.6,0.6,0.55);
  const headM=new THREE.MeshLambertMaterial({color:0x220a0a});
  const head=new THREE.Mesh(headG,headM);
  head.position.y=1.4;
  g.add(head);

  // Eyes (glowing red)
  const eyeG=new THREE.SphereGeometry(0.07,8,8);
  const eyeM=new THREE.MeshBasicMaterial({color:0xff0000});
  const eyeL=new THREE.Mesh(eyeG,eyeM);
  eyeL.position.set(-0.14,1.42,0.28);
  g.add(eyeL);
  const eyeR=eyeL.clone(); eyeR.position.x=0.14;
  g.add(eyeR);

  // Eye glow
  const eyeGlowL=new THREE.PointLight(0xff0000,0.8,2);
  eyeGlowL.position.set(-0.14,1.42,0.28);
  g.add(eyeGlowL);
  const eyeGlowR=eyeGlowL.clone(); eyeGlowR.position.x=0.14;
  g.add(eyeGlowR);

  // Arms
  const armG=new THREE.BoxGeometry(0.18,0.9,0.18);
  const armM=new THREE.MeshLambertMaterial({color:0x1a0a0a});
  const armL=new THREE.Mesh(armG,armM);
  armL.position.set(-0.44,0.7,0);
  armL.rotation.z=0.4;
  g.add(armL);
  const armR=armL.clone(); armR.position.x=0.44; armR.rotation.z=-0.4;
  g.add(armR);

  // Legs
  const legG=new THREE.BoxGeometry(0.22,0.7,0.22);
  const legM=new THREE.MeshLambertMaterial({color:0x0d0505});
  const legL=new THREE.Mesh(legG,legM);
  legL.position.set(-0.18,-0.35,0);
  g.add(legL);
  const legR=legL.clone(); legR.position.x=0.18;
  g.add(legR);

  g.userData.maze=true;
  scene.add(g);
  monster.group=g;
}

function spawnMonsterFarFrom(px,pz){
  // Find open cell far from player
  let best=null, bestDist=0;
  for(let y=1;y<MAZE_H-1;y++){
    for(let x=1;x<MAZE_W-1;x++){
      if(mazeGrid[y][x]!==0){
        const wx=x*CELL, wz=y*CELL;
        const d=Math.hypot(wx-px,wz-pz);
        if(d>bestDist){bestDist=d;best={x:wx,z:wz}}
      }
    }
  }
  if(best){monster.x=best.x;monster.z=best.z}
  monster.alive=true;
}

// ============================================================
//  PLAYER
// ============================================================
let player={
  x:CELL, z:CELL,
  yaw:0, pitch:0,
  speed:0.07,
  flashOn:true, battery:100,
  alive:true
};
let partner={x:-999,z:-999,yaw:0,name:'',visible:false};
let partnerMesh=null,partnerLabel=null;

function buildPartnerMesh(){
  if(partnerMesh)scene.remove(partnerMesh);
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.3),new THREE.MeshLambertMaterial({color:0x1e3a5f}));
  body.position.y=0.5; g.add(body);
  const head=new THREE.Mesh(new THREE.SphereGeometry(0.22,10,10),new THREE.MeshLambertMaterial({color:0xFDBCB4}));
  head.position.y=1.2; g.add(head);
  // Tiny flashlight beam
  const fl2=new THREE.SpotLight(0xfff8e7,0.4,4,Math.PI*0.12,0.5);
  fl2.position.set(0,1.1,0);
  const fl2Target=new THREE.Object3D();
  fl2Target.position.set(0,1.1,-2);
  g.add(fl2); g.add(fl2Target);
  fl2.target=fl2Target;
  g.userData.maze=true;
  partnerMesh=g;
  scene.add(g);
  g.visible=false;
}

// ============================================================
//  COLLISION
// ============================================================
function isWall(x,z){
  const cx=Math.round(x/CELL), cz=Math.round(z/CELL);
  if(cx<0||cx>=MAZE_W||cz<0||cz>=MAZE_H)return true;
  return mazeGrid[cz][cx]===0;
}

function tryMove(px,pz,dx,dz){
  const margin=0.35;
  let nx=px+dx, nz=pz+dz;
  if(!isWall(nx,pz))px=nx; else px+=dx*0.0;
  if(!isWall(px,nz))pz=nz; else pz+=dz*0.0;
  return{x:px,z:pz};
}

// ============================================================
//  CONTROLS
// ============================================================
let joyActive=false, joyDX=0, joyDY=0;
let lookActive=false, lookLX=0, lookLY=0;
let camYaw=0,camPitch=0;
let lookTouchId=null,joyTouchId=null;

const joyZone=document.getElementById('joyZone');
const joyKnob=document.getElementById('joyKnob');
const lookZone=document.getElementById('lookZone');
const JR=40; // max knob radius

function setupControls(){
  // Joystick
  joyZone.addEventListener('touchstart',e=>{
    const t=e.changedTouches[0];
    joyTouchId=t.identifier;
    joyActive=true;
  },{passive:true});
  document.addEventListener('touchmove',e=>{
    for(const t of e.changedTouches){
      if(t.identifier===joyTouchId){
        const rect=joyZone.getBoundingClientRect();
        const cx=rect.left+rect.width/2, cy=rect.top+rect.height/2;
        let dx=t.clientX-cx, dy=t.clientY-cy;
        const len=Math.hypot(dx,dy);
        if(len>JR){dx=dx/len*JR;dy=dy/len*JR;}
        joyDX=dx/JR; joyDY=dy/JR;
        joyKnob.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        e.preventDefault();
      }
      if(t.identifier===lookTouchId){
        const dx=t.clientX-lookLX, dy=t.clientY-lookLY;
        camYaw-=dx*0.003; camPitch-=dy*0.003;
        camPitch=Math.max(-0.5,Math.min(0.5,camPitch));
        lookLX=t.clientX; lookLY=t.clientY;
        e.preventDefault();
      }
    }
  },{passive:false});
  document.addEventListener('touchend',e=>{
    for(const t of e.changedTouches){
      if(t.identifier===joyTouchId){
        joyActive=false;joyDX=0;joyDY=0;
        joyKnob.style.transform='translate(-50%,-50%)';
        joyTouchId=null;
      }
      if(t.identifier===lookTouchId){lookActive=false;lookTouchId=null;}
    }
  });
  lookZone.addEventListener('touchstart',e=>{
    const t=e.changedTouches[0];
    if(lookTouchId!==null)return;
    lookTouchId=t.identifier;
    lookActive=true;
    lookLX=t.clientX; lookLY=t.clientY;
  },{passive:true});

  // Mouse fallback
  let mouseDown=false,lastMX=0,lastMY=0;
  canvas.addEventListener('mousedown',e=>{mouseDown=true;lastMX=e.clientX;lastMY=e.clientY});
  canvas.addEventListener('mousemove',e=>{
    if(!mouseDown||!gameOn)return;
    camYaw-=(e.clientX-lastMX)*0.003;
    camPitch-=(e.clientY-lastMY)*0.003;
    camPitch=Math.max(-0.5,Math.min(0.5,camPitch));
    lastMX=e.clientX;lastMY=e.clientY;
  });
  canvas.addEventListener('mouseup',()=>mouseDown=false);
  document.addEventListener('keydown',e=>{
    if(!gameOn)return;
    const s=player.speed*2;
    if(e.key==='ArrowUp'||e.key==='w'){const mv=tryMove(player.x,player.z,-Math.sin(camYaw)*s,-Math.cos(camYaw)*s);player.x=mv.x;player.z=mv.z;}
    if(e.key==='ArrowDown'||e.key==='s'){const mv=tryMove(player.x,player.z,Math.sin(camYaw)*s,Math.cos(camYaw)*s);player.x=mv.x;player.z=mv.z;}
    if(e.key==='ArrowLeft'||e.key==='a'){camYaw+=0.05;}
    if(e.key==='ArrowRight'||e.key==='d'){camYaw-=0.05;}
    if(e.key==='f')toggleFlash();
  });
}

function toggleFlash(){
  player.flashOn=!player.flashOn;
  document.getElementById('flashBtn').classList.toggle('on',player.flashOn);
}

// ============================================================
//  REDIS / MULTIPLAYER
// ============================================================
let myId=Math.random().toString(36).substr(2,8);
let myName='',roomCode='',isHost=false;
let pollInt=null;
let seenEvts=new Set();
let gameOn=false;
let gameStartTime=0;
let pArr=[];

function genCode(){return Math.random().toString(36).substr(2,4).toUpperCase()}

async function createRoom(){
  const n=document.getElementById('inName').value.trim();
  if(!n){alert('ƒ∞sminizi girin!');return}
  myName=n;roomCode=genCode();isHost=true;
  const data={players:{[myId]:{name:n,id:myId}},state:'waiting',events:[],ts:Date.now()};
  await rSet(`kacis:${roomCode}`,data);
  showWaiting();pollInt=setInterval(pollRoom,1200);pollRoom();
}
async function joinRoom(){
  const n=document.getElementById('inName').value.trim();
  const c=document.getElementById('inCode').value.trim().toUpperCase();
  if(!n){alert('ƒ∞smin yok!');return}
  if(!c){alert('Kod yok!');return}
  myName=n;roomCode=c;isHost=false;
  const data=await rGet(`kacis:${roomCode}`);
  if(!data){alert('Oda bulunamadƒ±!');return}
  if(Object.keys(data.players).length>=2){alert('Oda dolu!');return}
  data.players[myId]={name:n,id:myId};
  await rSet(`kacis:${roomCode}`,data);
  showWaiting();pollInt=setInterval(pollRoom,1200);pollRoom();
}
function showWaiting(){
  document.getElementById('lobby').style.display='none';
  document.getElementById('waiting').style.display='flex';
  document.getElementById('dispCode').textContent=roomCode;
}
async function pollRoom(){
  const data=await rGet(`kacis:${roomCode}`);
  if(!data)return;
  pArr=Object.values(data.players);

  if(document.getElementById('waiting').style.display!=='none'){
    const wp=document.getElementById('wPlayers');
    wp.innerHTML='';
    for(let i=0;i<2;i++){
      const p=pArr[i];
      wp.innerHTML+=`<div class="pslot"><div class="pdot ${p?'on':'off'}"></div><div class="pname">${p?p.name:'Bekleniyor...'}</div></div>`;
    }
    document.getElementById('wMsg').textContent=pArr.length>=2?'‚úÖ Oyun ba≈ülƒ±yor!':'Arkada≈üƒ±n katƒ±lsƒ±n...';

    if(pArr.length>=2){
      if(isHost&&data.state==='waiting'){
        const maze=generateMaze();
        data.state='playing';
        data.maze=maze;
        await rSet(`kacis:${roomCode}`,data);
      }
      if(data.state==='playing'&&data.maze){
        clearInterval(pollInt);
        mazeGrid=data.maze;
        beginGame();
      }
    }
  } else if(gameOn){
    // Process remote events
    processEvts(data.events||[]);
    // Update partner position from data
    const partnerData=pArr.find(p=>p.id!==myId);
    if(partnerData&&partnerData.px!==undefined){
      partner.x=partnerData.px;
      partner.z=partnerData.pz;
      partner.yaw=partnerData.yaw||0;
      partner.name=partnerData.name;
      partner.visible=true;
    }
    if(data.state==='won'){showWin()}
  }
}

async function pushEvt(ev){
  const data=await rGet(`kacis:${roomCode}`);
  if(!data)return;
  ev.id=Math.random().toString(36).substr(2,8);
  ev.ts=Date.now();
  if(!data.events)data.events=[];
  data.events.push(ev);
  if(data.events.length>40)data.events=data.events.slice(-40);
  await rSet(`kacis:${roomCode}`,data);
}

async function pushPos(){
  const data=await rGet(`kacis:${roomCode}`);
  if(!data||!data.players||!data.players[myId])return;
  data.players[myId].px=player.x;
  data.players[myId].pz=player.z;
  data.players[myId].yaw=camYaw;
  await rSet(`kacis:${roomCode}`,data);
}

function processEvts(evts){
  evts.forEach(ev=>{
    if(seenEvts.has(ev.id))return;
    seenEvts.add(ev.id);
    if(ev.pid===myId)return;
    if(ev.type==='dead'){triggerDeath(false)}
    if(ev.type==='won'){showWin()}
  });
}

// ============================================================
//  GAME BEGIN
// ============================================================
function beginGame(){
  document.getElementById('waiting').style.display='none';
  buildMaze3D();
  player.x=CELL; player.z=CELL;
  player.flashOn=true; player.battery=100; player.alive=true;
  monster.alive=true;
  camYaw=0; camPitch=0;
  flash.intensity=2.8;

  // Partner info
  const partData=pArr.find(p=>p.id!==myId);
  if(partData){partner.name=partData.name;document.getElementById('partnerId').textContent='üë• '+partData.name;}

  spawnMonsterFarFrom(player.x,player.z);
  buildMonster();
  buildPartnerMesh();
  setupControls();

  document.getElementById('topHud').style.display='flex';
  document.getElementById('flashBtn').style.display='block';
  document.getElementById('joyZone').style.display='block';
  document.getElementById('minimap').style.display='block';
  document.getElementById('compass2').style.display='flex';

  gameOn=true;
  gameStartTime=Date.now();
  seenEvts=new Set();

  pollInt=setInterval(async()=>{
    if(!gameOn)return;
    await pushPos();
    await pollRoom();
  },800);

  requestAnimationFrame(gameLoop);
}

// ============================================================
//  GAME LOOP
// ============================================================
let lastT=0;
let batteryTick=0;
let monsterStepTimer=0;
let frameCount=0;

function gameLoop(ts){
  if(!gameOn)return;
  requestAnimationFrame(gameLoop);

  const dt=Math.min((ts-lastT)/1000,0.05);
  lastT=ts;
  frameCount++;

  // ---- MOVE PLAYER ----
  if(joyActive){
    const spd=player.speed;
    const dx=-Math.sin(camYaw)*(-joyDY)*spd + -Math.sin(camYaw+Math.PI/2)*joyDX*spd;
    const dz=-Math.cos(camYaw)*(-joyDY)*spd + -Math.cos(camYaw+Math.PI/2)*joyDX*spd;
    const mv=tryMove(player.x,player.z,dx,dz);
    player.x=mv.x; player.z=mv.z;
  }

  // Camera
  camera.position.set(player.x,1.1,player.z);
  camera.rotation.order='YXZ';
  camera.rotation.y=camYaw;
  camera.rotation.x=camPitch;

  // Flashlight
  if(player.flashOn){
    batteryTick+=dt;
    if(batteryTick>0.5){batteryTick=0;player.battery=Math.max(0,player.battery-0.5);}
    flash.intensity=player.battery>0?2.8:0;
    if(player.battery<=0){player.flashOn=false;flash.intensity=0;}
    const bf=document.getElementById('batteryFill');
    bf.style.width=player.battery+'%';
    bf.style.background=player.battery>50?'#22c55e':player.battery>20?'#f59e0b':'#ef4444';
  } else {
    flash.intensity=0;
  }

  // Scene ambient darkness (no flashlight = very dark)
  const baseFog=player.flashOn?0.18:0.4;
  scene.fog.density=baseFog;
  ambient.intensity=player.flashOn?0.4:0.15;
  document.getElementById('darkOverlay').style.background=player.flashOn?'':'rgba(0,0,0,0.4)';

  // ---- MONSTER AI ----
  monsterStepTimer+=dt;
  if(monsterStepTimer>0.1&&monster.alive){
    monsterStepTimer=0;
    updateMonster();
  }

  // ---- PARTNER MESH ----
  if(partnerMesh&&partner.visible){
    partnerMesh.visible=true;
    partnerMesh.position.set(partner.x,0,partner.z);
    partnerMesh.rotation.y=partner.yaw+Math.PI;
  }

  // ---- EXIT CHECK ----
  if(exitMarker){
    const d=Math.hypot(player.x-exitMarker.x,player.z-exitMarker.z);
    if(d<1.2&&player.alive){
      gameOn=false;
      pushEvt({type:'won'});
      rGet(`kacis:${roomCode}`).then(data=>{
        if(data){data.state='won';rSet(`kacis:${roomCode}`,data);}
      });
      showWin();
      return;
    }
  }

  // Eerie light follows monster
  if(monster.group){
    eerieLight.position.set(monster.x,0.5,monster.z);
  }

  // ---- MINIMAP ----
  if(frameCount%3===0)drawMinimap();

  // ---- COMPASS ----
  const deg=Math.round(camYaw*180/Math.PI)%360;
  const dirs=['K','KD','D','GD','G','GB','B','KB'];
  const idx=Math.round(((-deg+720)%360)/45)%8;
  document.getElementById('cmpD').textContent=dirs[idx];
  document.getElementById('cmpDg').textContent=Math.abs(deg%360)+'¬∞';

  // ---- TIMER ----
  const elapsed=Math.floor((Date.now()-gameStartTime)/1000);
  const m=String(Math.floor(elapsed/60)).padStart(2,'0');
  const s=String(elapsed%60).padStart(2,'0');
  document.getElementById('timer').textContent=`‚è± ${m}:${s}`;

  renderer.render(scene,camera);
}

// ============================================================
//  MONSTER UPDATE
// ============================================================
function updateMonster(){
  if(!monster.alive)return;

  // Move toward player (simple approach)
  const dx=player.x-monster.x;
  const dz=player.z-monster.z;
  const dist=Math.hypot(dx,dz);

  // Warning effect
  const warnEl=document.getElementById('monWarn');
  const breathEl=document.getElementById('breathOverlay');
  if(dist<5){
    const intensity=Math.max(0,1-(dist/5));
    warnEl.style.borderWidth=Math.round(intensity*12)+'px';
    warnEl.style.opacity=intensity*0.6;
    breathEl.style.opacity=intensity*0.7;
    // Shake camera slightly
    if(dist<2){
      camera.position.x+=( Math.random()-0.5)*0.02;
      camera.position.z+=( Math.random()-0.5)*0.02;
    }
  } else {
    warnEl.style.opacity=0;breathEl.style.opacity=0;
  }

  // Caught?
  if(dist<0.7&&player.alive){
    triggerDeath(true);
    return;
  }

  // Move monster
  const spd=monster.speed*(dist<6?1.4:1);
  const ndx=dx/dist*spd, ndz=dz/dist*spd;
  const nm=tryMove(monster.x,monster.z,ndx,ndz);

  // Animate monster walking
  const t=Date.now()*0.005;
  if(monster.group){
    monster.group.position.set(nm.x,0,nm.z);
    monster.group.rotation.y=Math.atan2(dx,dz);
    monster.group.children.forEach((c,i)=>{
      if(i>3&&i<6)c.rotation.z=Math.sin(t+i)*0.3;
    });
  }
  monster.x=nm.x; monster.z=nm.z;
}

// ============================================================
//  DEATH / WIN
// ============================================================
async function triggerDeath(pushToRemote){
  if(!player.alive)return;
  player.alive=false; gameOn=false;
  if(pushToRemote) await pushEvt({type:'dead',pid:myId});

  flash.intensity=0;
  const ds=document.getElementById('deathScreen');
  ds.style.display='flex';
  setTimeout(()=>{
    ds.classList.add('show');
    setTimeout(()=>{
      document.getElementById('dTitle').style.display='block';
      document.getElementById('dSub').style.display='block';
      document.getElementById('dBtns').style.display='flex';
    },600);
  },100);
}

function showWin(){
  if(document.getElementById('winScreen').style.display==='flex')return;
  gameOn=false;
  const elapsed=Math.floor((Date.now()-gameStartTime)/1000);
  const m=String(Math.floor(elapsed/60)).padStart(2,'0');
  const s=String(elapsed%60).padStart(2,'0');
  document.getElementById('winTime').textContent=`S√ºre: ${m}:${s}`;
  document.getElementById('winScreen').style.display='flex';
}

function restartGame(){
  // Reset UI
  document.getElementById('deathScreen').style.display='none';
  document.getElementById('deathScreen').classList.remove('show');
  document.getElementById('dTitle').style.display='none';
  document.getElementById('dSub').style.display='none';
  document.getElementById('dBtns').style.display='none';
  document.getElementById('winScreen').style.display='none';

  // Regen maze
  if(isHost){
    generateMaze();
    buildMaze3D();
    rGet(`kacis:${roomCode}`).then(data=>{
      if(data){data.maze=mazeGrid;data.state='playing';data.events=[];rSet(`kacis:${roomCode}`,data);}
    });
  }

  player.x=CELL;player.z=CELL;player.battery=100;player.flashOn=true;player.alive=true;
  flash.intensity=2.8;camYaw=0;camPitch=0;
  spawnMonsterFarFrom(player.x,player.z);
  if(monster.group){monster.group.position.set(monster.x,0,monster.z);}
  gameStartTime=Date.now();
  seenEvts=new Set();
  gameOn=true;
  requestAnimationFrame(gameLoop);
}

function goLobby(){location.reload()}

// ============================================================
//  MINIMAP
// ============================================================
function drawMinimap(){
  const mc=document.getElementById('minimapCanvas');
  const ctx=mc.getContext('2d');
  const W=90,H=90;
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

  const cw=W/MAZE_W, ch=H/MAZE_H;
  for(let y=0;y<MAZE_H;y++){
    for(let x=0;x<MAZE_W;x++){
      const c=mazeGrid[y][x];
      if(c===0) ctx.fillStyle='#1a1a2e';
      else if(c===2) ctx.fillStyle='#00ff44';
      else ctx.fillStyle='#2a2a3e';
      ctx.fillRect(x*cw,y*ch,cw-0.5,ch-0.5);
    }
  }
  // Player dot
  const px=(player.x/CELL)*cw, pz=(player.z/CELL)*ch;
  ctx.fillStyle='#ef4444';
  ctx.beginPath();ctx.arc(px,pz,2.5,0,Math.PI*2);ctx.fill();

  // Partner
  if(partner.visible){
    const prx=(partner.x/CELL)*cw,prz=(partner.z/CELL)*ch;
    ctx.fillStyle='#22c55e';
    ctx.beginPath();ctx.arc(prx,prz,2,0,Math.PI*2);ctx.fill();
  }

  // Monster
  if(monster.alive){
    const mx=(monster.x/CELL)*cw, mz=(monster.z/CELL)*ch;
    ctx.fillStyle='#ff0000';
    ctx.beginPath();ctx.arc(mx,mz,2,0,Math.PI*2);ctx.fill();
  }
}

// ============================================================
//  MISC
// ============================================================
document.getElementById('inCode').addEventListener('input',e=>{e.target.value=e.target.value.toUpperCase()});
document.addEventListener('touchmove',e=>e.preventDefault(),{passive:false});

// Pre-render scene
renderer.render(scene,camera);
</script>
</body>
</html>
